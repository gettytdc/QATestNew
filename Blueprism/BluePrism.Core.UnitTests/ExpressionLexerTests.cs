#if UNITTESTS

using System.Collections.Generic;
using NUnit.Framework;
using BluePrism.BPCoreLib.Collections;
using BluePrism.BPCoreLib;
using BluePrism.Core.Expressions;

namespace BluePrism.Core.UnitTests
{
    /// <summary>
    /// Tests for the ExpressionLexer classes in the Core.Text namespace
    /// </summary>
    [TestFixture]
    public class ExpressionLexerTests
    {
        #region - Class-scope declarations -

        // Functions to test with - a temporary aberration
        private static readonly IBPSet<string> Functions = GetReadOnly.ISetFrom(
            "InStr", "Mid", "Left", "Right", "Sqrt"
        );

        /// <summary>
        /// Tests if the given name represents a function
        /// </summary>
        /// <param name="name">The name to test</param>
        /// <returns>True if the given name represents a function; false if it does
        /// not.</returns>
        public static bool IsFunction(string name)
        {
            return Functions.Contains(name);
        }

        /// <summary>
        /// Minor subclass of the ExpressionLexer which sets the IsFunctionDelegate
        /// to recognise the functions defined in <see cref="Functions"/>
        /// </summary>
        public class TestLexer : ExpressionLexer
        {
            public TestLexer(string expr)
                : base(expr)
            {
                IsFunctionDelegate = IsFunction;
            }

            internal TestLexer(string expr, ExpressionStyle style)
                : base(expr, style)
            {
                IsFunctionDelegate = IsFunction;
            }
        }

        #endregion

        #region - Utility Methods -

        /// <summary>
        /// Tests a lexing operation on a complete expression
        /// Note that this test method will strip all whitepsace tokens from the
        /// lexed result for brevity.
        /// </summary>
        /// <param name="text">The text containing the expression to be lexed</param>
        /// <param name="startState">The initial state to use for the lexer;
        /// typically the state from the lexing of the previous line</param>
        /// <param name="expected">The expected lexemes which should be generated by
        /// the lexer, ignoring any <see cref="ExpressionStyle.Whitespace">whitespace
        /// </see> lexemes.</param>
        private void RunTest(
            string text, params Lexeme[] expected)
        {
            ICollection<Lexeme> filteredLexes = CollectionUtil.Filter(
                new TestLexer(text).Perform(),
                delegate(Lexeme lex) {
                    return (lex.Style != ExpressionStyle.Whitespace); }
            );
            Assert.That(filteredLexes, Is.EqualTo(expected));
        }

        /// <summary>
        /// Tests a lexing operation with a specified 'start state' - ie. an initial
        /// state of the lexer to enter into at the start of lexing the expression.
        /// Typically, this is the state of the previous line in a multiline
        /// expression.
        /// Note that this test method will strip all whitepsace tokens from the
        /// lexed result for brevity.
        /// </summary>
        /// <param name="text">The text containing the expression to be lexed</param>
        /// <param name="startState">The initial state to use for the lexer;
        /// typically the state from the lexing of the previous line</param>
        /// <param name="expected">The expected lexemes which should be generated by
        /// the lexer, ignoring any <see cref="ExpressionStyle.Whitespace">whitespace
        /// </see> lexemes.</param>
        private void RunTest(
            string text, ExpressionStyle startState, params Lexeme[] expected)
        {
            ICollection<Lexeme> filteredLexes = CollectionUtil.Filter(
                new TestLexer(text, startState).Perform(),
                delegate(Lexeme lex) {
                    return (lex.Style != ExpressionStyle.Whitespace); }
            );
            Assert.That(filteredLexes, Is.EqualTo(expected));
        }

        /// <summary>
        /// Tests a lexing operation on the given expression text, <em>not</em>
        /// filtering out the whitespace lexemes in the result and comparing the
        /// output to the given set of lexemes.
        /// </summary>
        /// <param name="text">The expression text to lex</param>
        /// <param name="expected">The expected lexemes from the given expression.
        /// </param>
        private void RunUnfilteredTest(string text, params Lexeme[] expected)
        {
            Assert.That(new TestLexer(text).Perform(), Is.EqualTo(expected));
        }


        #endregion

        /// <summary>
        /// Test a complete expression in a string
        /// </summary>
        [Test]
        public void TestComplete()
        {
            RunTest("\"A string\"",
                new Lexeme(ExpressionStyle.String, "\"A string\"", 0));
            RunTest("\"A [contained] string\"",
                new Lexeme(ExpressionStyle.String, "\"A [contained] string\"", 0));
            RunTest("[A Variable]",
                new Lexeme(ExpressionStyle.DataItem, "[A Variable]", 0));
            RunTest("[A \"contained\" variable]",
                new Lexeme(ExpressionStyle.DataItem, "[A \"contained\" variable]", 0));
            RunTest("12345",
                new Lexeme(ExpressionStyle.Literal, "12345", 0));
            RunTest("[Var 1] = [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, "=", 8),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 10)
            );
            RunTest("[What is \"this\" then?]",
                new Lexeme(ExpressionStyle.DataItem, "[What is \"this\" then?]", 0));
            RunTest(" [Var 1]  = ((7 + [Var 2])*2.5)   ",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 1),
                new Lexeme(ExpressionStyle.Operator, "=", 10),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 12),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 13),
                new Lexeme(ExpressionStyle.Literal, "7", 14),
                new Lexeme(ExpressionStyle.Operator, "+", 16),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 18),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 25),
                new Lexeme(ExpressionStyle.Operator, "*", 26),
                new Lexeme(ExpressionStyle.Literal, "2.5", 27),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 30)
            );
            RunTest(" InStr(\"This is first\", \"not\") > 0",
                new Lexeme(ExpressionStyle.Function, "InStr", 1),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 6),
                new Lexeme(ExpressionStyle.String, "\"This is first\"", 7),
                new Lexeme(ExpressionStyle.ParamSeparator, ",", 22),
                new Lexeme(ExpressionStyle.String, "\"not\"", 24),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 29),
                new Lexeme(ExpressionStyle.Operator, ">", 31),
                new Lexeme(ExpressionStyle.Literal, "0", 33)
            );
        }

        [Test]
        public void TestCombinedOperators()
        {
            RunTest("[Var 1] >= [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, ">=", 8),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] <= [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, "<=", 8),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] <> [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, "<>", 8),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] >> [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, ">", 8),
                new Lexeme(ExpressionStyle.Operator, ">", 9),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] == [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, "=", 8),
                new Lexeme(ExpressionStyle.Operator, "=", 9),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] >< [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Operator, ">", 8),
                new Lexeme(ExpressionStyle.Operator, "<", 9),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("[Var 1] != [Var 2]",
                new Lexeme(ExpressionStyle.DataItem, "[Var 1]", 0),
                new Lexeme(ExpressionStyle.Default, "!", 8),
                new Lexeme(ExpressionStyle.Operator, "=", 9),
                new Lexeme(ExpressionStyle.DataItem, "[Var 2]", 11)
            );
            RunTest("1.5 >= Sqrt(-0.9)",
                new Lexeme(ExpressionStyle.Literal, "1.5", 0),
                new Lexeme(ExpressionStyle.Operator, ">=", 4),
                new Lexeme(ExpressionStyle.Function, "Sqrt", 7),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 11),
                new Lexeme(ExpressionStyle.Operator, "-", 12),
                new Lexeme(ExpressionStyle.Literal, "0.9", 13),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 16)
            );
            RunTest(">>=><>",
                new Lexeme(ExpressionStyle.Operator, ">", 0),
                new Lexeme(ExpressionStyle.Operator, ">=", 1),
                new Lexeme(ExpressionStyle.Operator, ">", 3),
                new Lexeme(ExpressionStyle.Operator, "<>", 4)
            );

            using (new CultureBlock("fr-FR"))
            {
                RunTest("1,5 >= Sqrt(-0,9)",
                    new Lexeme(ExpressionStyle.Literal, "1,5", 0),
                    new Lexeme(ExpressionStyle.Operator, ">=", 4),
                    new Lexeme(ExpressionStyle.Function, "Sqrt", 7),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 11),
                    new Lexeme(ExpressionStyle.Operator, "-", 12),
                    new Lexeme(ExpressionStyle.Literal, "0,9", 13),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 16)
                );
            }
        }

        /// <summary>
        /// Test a segment of a multiline expression, where the previous segment
        /// ended on an operator
        /// </summary>
        [Test]
        public void TestContinuedFromOperator()
        {
            RunTest("1 + ((0.5*8)/2.0) >= InStr(\"Three\", \"Oh Three!\")",
                ExpressionStyle.Operator,
                new Lexeme(ExpressionStyle.Literal, "1", 0),
                new Lexeme(ExpressionStyle.Operator, "+", 2),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 4),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 5),
                new Lexeme(ExpressionStyle.Literal, "0.5", 6),
                new Lexeme(ExpressionStyle.Operator, "*", 9),
                new Lexeme(ExpressionStyle.Literal, "8", 10),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 11),
                new Lexeme(ExpressionStyle.Operator, "/", 12),
                new Lexeme(ExpressionStyle.Literal, "2.0", 13),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 16),
                new Lexeme(ExpressionStyle.Operator, ">=", 18),
                new Lexeme(ExpressionStyle.Function, "InStr", 21),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 26),
                new Lexeme(ExpressionStyle.String, "\"Three\"", 27),
                new Lexeme(ExpressionStyle.ParamSeparator, ",", 34),
                new Lexeme(ExpressionStyle.String, "\"Oh Three!\"", 36),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 47)
            );
        }

        /// <summary>
        /// Test a segment of a multiline expression, where the previous segment
        /// ended within a string
        /// </summary>
        [Test]
        public void TestContinuedFromString()
        {
            RunTest("\r\nCheers\r\n--\r\nStu\r\n\" & \r\n [Signature]",
                ExpressionStyle.String,
                new Lexeme(ExpressionStyle.String, "\r\nCheers\r\n--\r\nStu\r\n\"", 0),
                new Lexeme(ExpressionStyle.Operator, "&", 21),
                new Lexeme(ExpressionStyle.DataItem, "[Signature]", 26)
            );
        }

        /// <summary>
        /// Test a segment of a multiline expression, where the previous segment
        /// ended within a literal
        /// </summary>
        [Test]
        public void TestContinuedFromLiteral()
        {
            RunTest(".5) & (Mid([Surname, Forename], 0,5) = \";\"))",
                ExpressionStyle.Literal,
                new Lexeme(ExpressionStyle.Literal, ".5", 0),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 2),
                new Lexeme(ExpressionStyle.Operator, "&", 4),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 6),
                new Lexeme(ExpressionStyle.Function, "Mid", 7),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 10),
                new Lexeme(ExpressionStyle.DataItem, "[Surname, Forename]", 11),
                new Lexeme(ExpressionStyle.ParamSeparator, ",", 30),
                new Lexeme(ExpressionStyle.Literal, "0", 32),
                new Lexeme(ExpressionStyle.ParamSeparator, ",", 33),
                new Lexeme(ExpressionStyle.Literal, "5", 34),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 35),
                new Lexeme(ExpressionStyle.Operator, "=", 37),
                new Lexeme(ExpressionStyle.String, "\";\"", 39),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 42),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 43)
            );
        }

        /// <summary>
        /// Tests that whitespace is maintained and correctly lexed in a lexing run
        /// </summary>
        [Test]
        public void TestWhitespace()
        {
            RunUnfilteredTest(" ", new Lexeme(ExpressionStyle.Whitespace, " ", 0));
            RunUnfilteredTest("\t \r\n \t\t\r\n",
                new Lexeme(ExpressionStyle.Whitespace, "\t \r\n \t\t\r\n", 0));
            RunUnfilteredTest("\t 5\r\nMid() \t\t\0\r\n",
                new Lexeme(ExpressionStyle.Whitespace, "\t ", 0),
                new Lexeme(ExpressionStyle.Literal, "5", 2),
                new Lexeme(ExpressionStyle.Whitespace, "\r\n", 3),
                new Lexeme(ExpressionStyle.Function, "Mid", 5),
                new Lexeme(ExpressionStyle.OpenBracket, "(", 8),
                new Lexeme(ExpressionStyle.CloseBracket, ")", 9),
                new Lexeme(ExpressionStyle.Whitespace, " \t\t", 10),
                new Lexeme(ExpressionStyle.Default, "\0", 13),
                new Lexeme(ExpressionStyle.Whitespace, "\r\n", 14)
            );
            // Test for a "&nbsp;" char (\u00a0)
            RunUnfilteredTest(" \u00a0\t",
                new Lexeme(ExpressionStyle.Whitespace, " \u00a0\t", 0));
        }

        /// <summary>
        /// Tests expressions with decimal and list separators, ensuring that they
        /// are correctly picked up when the current culture changes them
        /// </summary>
        [Test]
        public void TestCulturalDifferences()
        {
            using (new CultureBlock("en-GB"))
            {
                // This is a minor variation on the expression in the
                // TestContinuedFromLiteral above (comma instead of dot at start)
                RunTest(",5) & (Mid([Surname, Forename], 0,5) = \";\"))",
                    ExpressionStyle.Literal,
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 0),
                    new Lexeme(ExpressionStyle.Literal, "5", 1),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 2),
                    new Lexeme(ExpressionStyle.Operator, "&", 4),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 6),
                    new Lexeme(ExpressionStyle.Function, "Mid", 7),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 10),
                    new Lexeme(ExpressionStyle.DataItem, "[Surname, Forename]", 11),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 30),
                    new Lexeme(ExpressionStyle.Literal, "0", 32),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 33),
                    new Lexeme(ExpressionStyle.Literal, "5", 34),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 35),
                    new Lexeme(ExpressionStyle.Operator, "=", 37),
                    new Lexeme(ExpressionStyle.String, "\";\"", 39),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 42),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 43)
                );
            }

            // This is exactly the same expression as above; invalid using the
            // french culture, but still needs to be lexed without error
            using (new CultureBlock("fr-FR"))
            {
                RunTest(",5) & (Mid([Surname, Forename], 0,5) = \";\"))",
                    ExpressionStyle.Literal,
                    new Lexeme(ExpressionStyle.Literal, ",5", 0),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 2),
                    new Lexeme(ExpressionStyle.Operator, "&", 4),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 6),
                    new Lexeme(ExpressionStyle.Function, "Mid", 7),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 10),
                    new Lexeme(ExpressionStyle.DataItem, "[Surname, Forename]", 11),
                    new Lexeme(ExpressionStyle.Default, ",", 30),
                    new Lexeme(ExpressionStyle.Literal, "0,5", 32),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 35),
                    new Lexeme(ExpressionStyle.Operator, "=", 37),
                    new Lexeme(ExpressionStyle.String, "\";\"", 39),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 42),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 43)
                );
            }

            using (new CultureBlock("fr-FR"))
            {
                RunTest(",5) & (Mid([Surname, Forename], 0,5) = \";\"))",
                    ExpressionStyle.Literal,
                    new Lexeme(ExpressionStyle.Literal, ",5", 0),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 2),
                    new Lexeme(ExpressionStyle.Operator, "&", 4),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 6),
                    new Lexeme(ExpressionStyle.Function, "Mid", 7),
                    new Lexeme(ExpressionStyle.OpenBracket, "(", 10),
                    new Lexeme(ExpressionStyle.DataItem, "[Surname, Forename]", 11),
                    new Lexeme(ExpressionStyle.Default, ",", 30),
                    new Lexeme(ExpressionStyle.Literal, "0,5", 32),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 35),
                    new Lexeme(ExpressionStyle.Operator, "=", 37),
                    new Lexeme(ExpressionStyle.String, "\";\"", 39),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 42),
                    new Lexeme(ExpressionStyle.CloseBracket, ")", 43)
                );
            }

            using (new CultureBlock("en-GB"))
            {
                RunTest("1,2,3,4,5", ExpressionStyle.OpenBracket,
                    new Lexeme(ExpressionStyle.Literal, "1", 0),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 1),
                    new Lexeme(ExpressionStyle.Literal, "2", 2),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 3),
                    new Lexeme(ExpressionStyle.Literal, "3", 4),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 5),
                    new Lexeme(ExpressionStyle.Literal, "4", 6),
                    new Lexeme(ExpressionStyle.ParamSeparator, ",", 7),
                    new Lexeme(ExpressionStyle.Literal, "5", 8)
                );

                RunTest("1.2.3.4.5", ExpressionStyle.OpenBracket,
                    new Lexeme(ExpressionStyle.Literal, "1.2", 0),
                    new Lexeme(ExpressionStyle.Literal, ".3", 3),
                    new Lexeme(ExpressionStyle.Literal, ".4", 5),
                    new Lexeme(ExpressionStyle.Literal, ".5", 7)
                );
            }

            using (new CultureBlock("fr-FR"))
            {
                RunTest("1;2;3;4;5", ExpressionStyle.OpenBracket,
                    new Lexeme(ExpressionStyle.Literal, "1", 0),
                    new Lexeme(ExpressionStyle.ParamSeparator, ";", 1),
                    new Lexeme(ExpressionStyle.Literal, "2", 2),
                    new Lexeme(ExpressionStyle.ParamSeparator, ";", 3),
                    new Lexeme(ExpressionStyle.Literal, "3", 4),
                    new Lexeme(ExpressionStyle.ParamSeparator, ";", 5),
                    new Lexeme(ExpressionStyle.Literal, "4", 6),
                    new Lexeme(ExpressionStyle.ParamSeparator, ";", 7),
                    new Lexeme(ExpressionStyle.Literal, "5", 8)
                );

                RunTest("1,2,3,4,5", ExpressionStyle.OpenBracket,
                    new Lexeme(ExpressionStyle.Literal, "1,2", 0),
                    new Lexeme(ExpressionStyle.Literal, ",3", 3),
                    new Lexeme(ExpressionStyle.Literal, ",4", 5),
                    new Lexeme(ExpressionStyle.Literal, ",5", 7)
                );
            }
        }

        [Test]
        public void TestEmpty()
        {
            RunTest(""); // No lexemes created
        }

        [Test]
        public void TestInvalid()
        {
            RunTest("\"", new Lexeme(ExpressionStyle.String, "\"", 0));
            RunTest("[x]+=1",
                new Lexeme(ExpressionStyle.DataItem, "[x]", 0),
                new Lexeme(ExpressionStyle.Operator, "+", 3),
                new Lexeme(ExpressionStyle.Operator, "=", 4),
                new Lexeme(ExpressionStyle.Literal, "1", 5)
            );
            RunTest("x]",
                new Lexeme(ExpressionStyle.Default, "x]", 0));

            // No opening quote - quote found at the end
            RunTest("An unending string? Or an unstarting one?\"",
                new Lexeme(ExpressionStyle.Default, "An", 0),
                new Lexeme(ExpressionStyle.Default, "unending", 3),
                new Lexeme(ExpressionStyle.Default, "string?", 12),
                new Lexeme(ExpressionStyle.Default, "Or", 20),
                new Lexeme(ExpressionStyle.Default, "an", 23),
                new Lexeme(ExpressionStyle.Default, "unstarting", 26),
                new Lexeme(ExpressionStyle.Default, "one?", 37),
                new Lexeme(ExpressionStyle.String, "\"", 41)
            );

            // Same expression, but initialised with the initial style set to
            // 'String' - ie. continuing a string from a previous line/text segment
            RunTest("An unending string? Or an unstarting one?\"",
                ExpressionStyle.String,
                new Lexeme(ExpressionStyle.String,
                    "An unending string? Or an unstarting one?\"", 0)
            );

            // Opening quote - no quote at the end
            RunTest("\"An unending string? Or an unstarting one?",
                new Lexeme(ExpressionStyle.String,
                    "\"An unending string? Or an unstarting one?", 0)
            );

            RunTest("+-&*========",
                new Lexeme(ExpressionStyle.Operator, "+", 0),
                new Lexeme(ExpressionStyle.Operator, "-", 1),
                new Lexeme(ExpressionStyle.Operator, "&", 2),
                new Lexeme(ExpressionStyle.Operator, "*", 3),
                new Lexeme(ExpressionStyle.Operator, "=", 4),
                new Lexeme(ExpressionStyle.Operator, "=", 5),
                new Lexeme(ExpressionStyle.Operator, "=", 6),
                new Lexeme(ExpressionStyle.Operator, "=", 7),
                new Lexeme(ExpressionStyle.Operator, "=", 8),
                new Lexeme(ExpressionStyle.Operator, "=", 9),
                new Lexeme(ExpressionStyle.Operator, "=", 10),
                new Lexeme(ExpressionStyle.Operator, "=", 11)
            );

            RunTest("0.5.0",
                new Lexeme(ExpressionStyle.Literal, "0.5", 0),
                new Lexeme(ExpressionStyle.Literal, ".0", 3)
            );

            RunTest(".", new Lexeme(ExpressionStyle.Default, ".", 0));
        }
    }
}

#endif
