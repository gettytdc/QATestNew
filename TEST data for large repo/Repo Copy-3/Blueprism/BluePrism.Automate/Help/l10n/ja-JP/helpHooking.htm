<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <link type="text/css" href="AutomateHelp.css" rel="stylesheet"/>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>アプリケーションフッキング</title>
</head>

<body>
    <div class="header">
        <h1 class="pagetitle">ヘルプ</h1>
    </div>
    
    <h3>概要</h3>
    <p>
 アプリケーションフッキングは、グラフィカルアプリケーションからデータを取得する侵入的な自動化技術です。情報をフィードバックするために、対象アプリケーションのメモリ領域に実行ファイルコードを挿入します。この手法は技術的には侵入的ですが、対象アプリケーションの動作には影響しません。
	</p>
	<p>
 データをフィードバックするプロセスは、次のように要約できます。Blue Prismは、アプリケーションがどこにデータを送信するかを予測し、その場所でデータをリッスンし、データを受けて観察してから、目的の宛先に渡します。
 このプロセスのより技術的な説明を以下に概説します。
	</p>
    
    <h3>フッキングのしくみ</h3>
    <p>
 以下の説明にはある程度の技術的知識が必要です。
	</p>
	<p>
 Blue Prismは、対象アプリケーションのWindows user32、Kernel32、gdi32ライブラリにある関数の実装を置き換えます。新しい実装は渡されたパラメーターを記録し、Blue Prismでこの情報を利用できるようにしてから、元の実装を呼び出して、アプリケーションが以前と同じように動作するようにします。
	</p>
	<p>
 置き換えられる関数の例としては、DrawTextAやSetWindowPosがあります。これらの関数によって、Blue Prismはアプリケーション内の画面上に表示されるテキストや作成されるウィンドウを（それぞれ）把握できます。
	</p>
	<p>
 Blue Prismはこの情報を1つのオブジェクトモデルにまとめ、収集された各情報と各情報が全体とどのように関連するかを記憶します。
 モデルはリアルタイムで更新され、古い情報を破棄し、新しい情報を常に観察します。つまり、Blue Prismは常にアプリケーションの最新の状態を認識し、それを報告する準備ができます。
	</p>
	<p>
 この機能により、Blue Prismは<a href="helpObjectStudio.htm">オブジェクトスタジオ</a>から対象アプリケーションを操作し、たとえば、オブジェクトモデルで予想される機能を<a href="frmStagePropertiesWait.htm">待機</a>したり、モデルからデータを<a href="frmStagePropertiesRead.htm">読み取って</a>業務プロセスで使用したりできます。
	</p>
	
	
    <h3>用途</h3>
    <p>
 フッキングは通常、これ以上適切な統合方式がない場合に、最後の手段として使用されます（ここで「これ適切な」とは、<a href="helpJavaAutomation.htm">Java統合</a>のように、より高いプラットフォーム依存度のメソッドを意味します）。
	</p>
	<p>
 一般的にフッキングは、Windows APIが提供する機能を再実装するフレームワークに対し、対象アプリケーションを実装する場合に使用されます。たとえば、Windows APIを介してボタンを作成する代わりに、フレームワークが自身のボタンをスクリーン上に表示できます。その結果、Blue PrismがWindows統合技術を使用してアプリケーションの検査を試行すると、単一のウィンドウのみが表示され、ボタン、編集フィールド、コンボボックスなどのいくつかの個別コンポーネントを含むウィンドウは表示されません。この場合、フッキングすることでBlue Prismはボタン上に描画されるテキストを確認し、ボタンの位置を推測できます。
	</p>
	<p>
 フッキングが適しているフレームワークの例には、<a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>、<a href="http://en.wikipedia.org/wiki/GTK+">GTK+</a>、<a href="http://en.wikipedia.org/wiki/Qt_%28toolkit%29">Qt</a>があります。
	</p>
	
	<h3>長所</h3>
	<p>
 フッキング技術には、従来のマクロベースの自動化アプローチを超える重要な機能があるため有効です。
	</p>
	<ul>
		<li class="bold">信頼性
			<p class="indented">
 マクロベースの自動化は、事前に決められた画面座標でマウスクリックしてメッセージを送信するだけの「クリックして祈る」アプローチに依存しています。こうしたテクニックはエラーを起こしやすく、非常に予測が困難です。特に、ソフトウェアのアップグレード、画面の解像度の変更、さまざまなPCで使われるテーマやスキンの違いのため、アプリケーションの表示方法が変わる場合に失敗します。これにより、マクロが機能しなくなる、意図しない動作が引き起こされる、データが破損するなどの可能性があります。
			</p>
		</li>
		<li class="bold">データ取得のしやすさ
			<p class="indented">
 マクロベースの自動化には、フェイルセーフなデータ取得方法はありません。せいぜい、単にマウスをクリックして目的の要素にフォーカスし、キーボードショートカットを送信してすべてのテキストを選択し、選択したテキストをクリップボードにコピーできる程度です。そのため、データは損なわれやすく、多くの場合、不完全になります。これとは対照的に、フッキングはすべてのデータをリアルタイムでキャプチャし、データの存在も検出できます。次の「準備状況を検出する」を参照してください。
			</p>
		</li>
		<li class="bold">準備状況を検出する
			<p class="indented">
 マクロベースの自動化では、通常単なる休止（一定時間の待機）を基本に、アプリケーションが入力を受け取る準備ができている、またはデータが存在して読み取り可能になっているのを確認します。
 たとえば、［詳細を取得］ボタンをクリックした後、アプリケーションが画面にデータを表示できるようになるには、リモートデータベースからの応答を待機する必要があります。この操作の完了にかかる時間は予測できず、データベースサーバーの負荷によって大きく異なる可能性があります。その結果、対象アプリケーションの準備が整う前にマクロが次のステージに進むことが原因で、マクロが意図しない動作をすることがよくあります。
			</p>
			<p class="indented">
 対照的に、Blue Prismのフッキングモデルでは、対象アプリケーションの状態の詳細を把握できます。
 モデルには、どのコンポーネントおよびどの情報が存在するかの情報が含まれます。たとえば、データがポップアップウィンドウに表示される場合、Blue Prismは、ウィンドウが表示されて実際にそのウィンドウ内にデータが表示されるまで、必要なだけ待機できます。この待機機能は、マクロにおける（たとえば）30秒の固定待機（ポップアップウィンドウが表示されるのに「ほとんどの」場合に十分だと考えられる時間の長さ）と比較できます。
			</p>
		</li>
		<li class="bold">速度
			<p class="indented">
 上のように、Blue Prismには、対象アプリケーションの準備状況を検出するための高度な待機機能があります。つまり、各ステージで、必要なだけ待機すればよいのです。ポップアップウィンドウを待機する例をもう一度考えてみます。実際には5秒が一般的に必要な待機期間であっても、マクロは99％のケースで（認められる）信頼性を保証するため、それぞれの場合に30秒間待機する決定をするかもしれません。フッキングを行うと、アプリケーションの準備ができ次第すぐに自動化を続行できるので、優れたパフォーマンスにつながります。
			</p>
		</li>
	</ul>
	<p>
 要約すると、フッキングテクノロジーは、以前には自動化は適切と考えられなかったかもしれない状況で、自動化を実行可能にし、有効にします。
	</p>
    
    
    <h3>短所</h3>
    <p>
 フッキングは高度なテクノロジーであると同時に、（前述のように）自動化を容易にする明らかな、つまり直接的な方法がないという悪条件を克服します。このため、推奨される他の技術と比べ不完全に見えます。注意事項は以下のとおりです。
	</p>
	<ul>
		<li class="bold">アプリケーションの起動方法をコントロールしにくい
			<p class="indented">
 この手法に内在する本質的な理由から、Blue Prismがフッキングを実行できるのはアプリケーションの起動時のみです。このため、アプリケーションはBlue Prismによって起動される必要があります。他の統合手法と同様に、すでに実行中の場合にはアタッチできません。
			</p>
		</li>
		<li class="bold">ビジネスオブジェクトの作成に関連した作業が増える
			<p class="indented">
 オブジェクトモデル内の特定のデータを混同しないように、ユーザーは何らかの作業をする必要があります。たとえば、Blue Prismには、フッキングで取得したテキストがボタンのテキストの一部なのか、近くのコンボボックスの一部なのかを把握する手段がありません。ユーザーは問題を回避するために注意を払う必要があります。
			</p>
			<p class="indented">
 このため、ユーザーはフッキングメソッドを通して、Blue Prismから見たアプリケーションの動作と利用可能な情報に基づき、対象アプリケーションを独創的な方法で操作する必要があるかもしれません。利用可能な情報はアプリケーションによって異なります。
			</p>
		</li>
		<li class="bold">既製の簡便なメソッドがない
			<p class="indented">
 フッキングは特定のツールキットとその機能では動作しないため（Blue Prismの<a href="helpJavaAutomation.htm">Java自動化テクノロジー</a>などとは対照的）、特定のタイプのユーザーインターフェイス要素と連携する設計の特定の機能セットは提供できません。そのため、ユーザーが（たとえば）コンボボックスアイテムの選択をシミュレートするために一部の作業を手動で行う必要があります。一方で、Windowsアプリケーションでは、Blue Prismが代わりにコンボボックスアイテムの選択作業を実行できるので、ユーザーが行う必要があるのは、<a href="frmStagePropertiesNavigate.htm">遷移ステージ</a>を介して指示を発行するだけです。
			</p>
		</li>
	</ul>
	
	   
    
    <h3>フッキングを利用すべきタイミング<a name="WhenToUseHooking" id="WhenToUseHooking"></a></h3>
    <p>
 端的に言えば、フッキングは最後の手段です。利用可能、適用可能であれば、ブラウザーの自動化や<a href="helpJavaAutomation.htm">Java自動化</a>などのより具体的な手法を利用してください。
	</p>
    
</body>
</html>
